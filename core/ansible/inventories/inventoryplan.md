# Inventory Plan — HybridOps.Studio

**Purpose**
Define a safe, scalable, and auditable way to manage infrastructure addressing and policy for automation across on‑prem, EVE‑NG sub‑sites, Azure, and GCP — **without storing real IPs in Git**.

---

## Principles (SSOT, but zero secrets in Git)
- **Placeholders in Git:** Inventories in Git use token IPs only (e.g., `ansible_host=XX.XX.XX.00`).
- **Runtime resolution:** Real IPs are produced and consumed at **run time** (Terraform → object storage → Ansible `ip_mapper`).
- **Environment‑scoped & idempotent:** Each environment (dev/staging/prod) has its own runtime file and is reproducible from code.
- **Policy in Git:** SLOs and thresholds (RTO/RPO, autoscale signals) are versioned as YAML (no secrets).
- **No global JSON ignores:** Only target generated JSON with precise patterns.

---

## Governed Pipeline (EGF block)

```mermaid
flowchart LR
  classDef gov fill:#001f3f,stroke:#A0C4FF,color:#fff
  classDef inv fill:#0b3d91,stroke:#A0C4FF,color:#fff
  classDef sel fill:#2a6f97,stroke:#A0C4FF,color:#fff
  classDef map fill:#1f7a8c,stroke:#A0C4FF,color:#fff
  classDef val fill:#2b9348,stroke:#A0C4FF,color:#fff
  classDef dep fill:#7f4f24,stroke:#E9C46A,color:#fff

  A[env_guard\nGovernance & CID]:::gov --> B[gen_inventory\nPlaceholder Inventory]:::inv
  B --> C[host_selector\nTarget Selection]:::sel
  C --> D[ip_mapper\nDynamic IP Resolution]:::map
  D --> E[connectivity_test\nPre-Deploy Gate]:::val
  E --> F[deployment\nControlled Rollout]:::dep
```

**Where roles live:** Ansible **collection** layout
`core/ansible/collections/ansible_collections/hybridops/common/roles/{env_guard,gen_inventory,host_selector,ip_mapper,...}`

---

## Repo Layout (inventory + policy)

```
core/
  ansible/
    inventories/
      dev/
        hosts.ini                  # placeholders only (generated by gen_inventory)
        group_vars/
          all/
            policy.yml             # RTO/RPO, autoscale thresholds (no secrets)
            secret.yml             # vaulted credentials/tokens (no IPs)
      staging/ → mirrors dev vars
      prod/    → mirrors dev vars
```

**Example `hosts.ini` (placeholders only)**
```ini
[cisco_routers]
coreR-1-Tok ansible_host=XX.XX.XX.00
coreR-2-Lag ansible_host=XX.XX.XX.00

[cisco_switches]
Asw-1-Tok  ansible_host=XX.XX.XX.00
Dst-1-Tok  ansible_host=XX.XX.XX.00
```

**Example `group_vars/all/policy.yml`**
```yaml
policy:
  rto_minutes: 15
  rpo_minutes: 5
  autoscale:
    scale_out_threshold: 0.70   # +2 workers @ 70%
    scale_in_threshold: 0.40    # scale-in < 40%
  decision_service:
    cost_weight: 0.5
    slo_weight: 0.5
```

> Keep **secrets** (tokens, passwords) in `secret.yml` via **Ansible Vault**. Do **not** store IPs in vault either; IPs are runtime data.

---

## Runtime Source of Truth (outside Git)

### File shape
`hosts_runtime.json` — one per environment.
```json
{
  "env": "prod",
  "updated_utc": "2025-09-21T12:30:00Z",
  "cid": "CID-20250921-1230-abc123",
  "inventory": {
    "cisco_routers": [
      { "name": "coreR-1-Tok", "ip": "172.16.13.21" },
      { "name": "coreR-2-Lag", "ip": "172.16.13.20" }
    ],
    "windows_servers": [
      { "name": "dc-01", "ip": "172.16.10.3" }
    ],
    "k8s_nodes": [
      { "name": "kcp-01", "ip": "10.10.20.10" }
    ]
  }
}
```

### Storage locations
- **Primary (cloud):**
  - Azure Blob: `https://<storage>.blob.core.windows.net/hybridops-runtime/<env>/hosts_runtime.json`
  - GCS: `gs://hybridops-runtime/<env>/hosts_runtime.json`
- **Optional on‑prem cache:** NAS path (e.g., `nfs://nas/automation/runtime/<env>/hosts_runtime.json`) for local runs.

### Publication
- **Terraform** (per environment) writes outputs (IPs) and the pipeline publishes a **single JSON** to Blob/GCS.
- Use short‑lived SAS / signed URLs for Ansible retrieval.

---

## Ansible: mapping runtime IPs

**`ip_mapper` role (example pattern)**
- Downloads `hosts_runtime.json` (signed URL) to a temp path.
- For each host in the selected scope, sets `ansible_host` to the runtime IP.
- Fails fast if host missing or file stale.

**Usage snippet**
```yaml
- name: Map runtime IPs for selected hosts
  hosts: all
  gather_facts: no
  tasks:
    - name: Download runtime hosts file
      get_url:
        url: "{{ runtime_hosts_url }}"
        dest: "/tmp/hosts_runtime.json"
        mode: "0600"

    - name: Load runtime hosts
      set_fact:
        hosts_runtime: "{{ lookup('file', '/tmp/hosts_runtime.json') | from_json }}"

    - name: Apply runtime IPs
      set_fact:
        ansible_host: >-
          {{ (hosts_runtime.inventory.get(group_names[0], []) |
              selectattr('name','equalto', inventory_hostname) | list | first).ip }}
      when: hosts_runtime is defined
```

---

## Terraform → Blob/GCS (publish runtime file)

**Terraform outputs (example)**
```hcl
output "router_coreR_1_tok_ip" { value = azurerm_network_interface.coreR_1_tok.private_ip_address }
output "router_coreR_2_lag_ip" { value = google_compute_instance.coreR_2_lag.network_interface[0].network_ip }
```

**Pipeline step (pseudo)**
```bash
python tools/build_hosts_runtime.py   --env prod   --tfstate ./core/terraform-infra/environments/prod/terraform.tfstate   --out /tmp/hosts_runtime.json

# Azure
az storage blob upload --overwrite   --account-name "$AZ_ACCT" --container-name hybridops-runtime   --name prod/hosts_runtime.json --file /tmp/hosts_runtime.json

# GCS
gsutil cp -a private /tmp/hosts_runtime.json gs://hybridops-runtime/prod/hosts_runtime.json
```

> The repo **never** receives real IPs; only Blob/GCS do.

---

## Failover Behavior

- If **on‑prem is down**, Ansible retrieves `hosts_runtime.json` from **cloud storage**.
- The **Decision Service** may switch target to Azure/GCP; runtime file reflects the active endpoints.
- Keep the last *N* versions with timestamps for rollbacks/audit.

---

## IP strategy (recommended)

- **On‑prem:** Prefer **static** addresses for core nodes (routers, firewalls, CP).
- **Cloud:** Prefer **stable** addressing: fixed private IPs for nodes that automation targets directly; otherwise use **private DNS** (A records) and include resolved IPs in the runtime file for transparency.
- Always map **name → IP** in `hosts_runtime.json` for deterministic runs.

---

## .gitignore (targeted)

```gitignore
# Generated inventory artifacts
core/ansible/inventories/*/hosts.ini
logs/
*.retry

# Terraform outputs you don't want in Git
core/terraform-infra/output/*.json
```

> Do **not** ignore `*.json` globally; keep ignores precise.

---

## Migration (from git‑stored IPs)

1. Export current `ip_addresses.yml` to a **temporary** runtime JSON.
2. Upload that JSON to Blob/GCS per environment.
3. Remove IPs from Git (leave placeholders only).
4. Wire `ip_mapper` to use the signed URL.
5. Rotate any leaked credentials and re‑vault `secret.yml` (no IPs).

---

## Checklist

- [ ] Placeholders only in Git inventories.
- [ ] `policy.yml` committed (RTO/RPO, autoscale).
- [ ] Terraform publishes `hosts_runtime.json` to Blob/GCS per env.
- [ ] `ip_mapper` consumes runtime file and sets `ansible_host`.
- [ ] CI secrets store holds storage credentials/tokens.
- [ ] Retain N versions of runtime file; include `cid` + timestamp.

---

**Owner:** Jeleel Muibi · **License:** MIT‑0 · **Updated:** 2025‑09‑21
