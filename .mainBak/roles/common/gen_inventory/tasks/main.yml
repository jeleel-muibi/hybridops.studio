---
# SPDX-License-Identifier: MIT-0
# Author: Jeleel Muibi (hybridops.studio)
# Created: 2025-09-10 22:45:00 UTC
# Updated: 2025-09-10 â€” Initial implementation of inventory generation logic
#
# Purpose: Resolve project root, validate inputs, and load environment data for dynamic inventory.

- ansible.builtin.include_tasks: _validate.yml

- name: Fail if 'env' is not provided
  ansible.builtin.fail:
    msg: "Variable 'env' is required (e.g., -e env=dev)."
  when: env is not defined or env is none or (env | trim) == ""

- name: Normalize env
  ansible.builtin.set_fact:
    env: "{{ env | lower | trim }}"
  delegate_to: localhost
  run_once: true

# Project root resolution
- name: Compute project root candidates
  vars:
    _root_explicit: "{{ project_root | default('') | trim }}"
    _root_env: "{{ lookup('env', 'HYBRIDOPS_ROOT') | default('', true) | trim }}"
    _root_git: "{{ lookup('pipe', 'git rev-parse --show-toplevel') | default('', true) | trim }}"
    _root_role: "{{ (role_path is defined and '/roles/' in role_path) | ternary(role_path.split('/roles/')[0], '') | trim }}"
    _root_playbook: "{{ (playbook_dir | realpath) | trim }}"
  ansible.builtin.set_fact:
    root_candidates_raw:
    - { label: "explicit_var", path: "{{ _root_explicit }}" }
    - { label: "environment_var", path: "{{ _root_env }}" }
    - { label: "git_repo_root", path: "{{ _root_git }}" }
    - { label: "role_path_root", path: "{{ _root_role }}" }
    - { label: "playbook_dir_fallback", path: "{{ _root_playbook }}" }
  delegate_to: localhost
  run_once: true

- name: Filter out empty root candidates
  ansible.builtin.set_fact:
    root_candidates: "{{ root_candidates_raw | rejectattr('path', 'equalto', '') | list }}"
  delegate_to: localhost
  run_once: true

- name: Fail if no non-empty root candidates
  ansible.builtin.fail:
    msg: "No valid project root candidates were found."
  when: root_candidates | length == 0
  delegate_to: localhost
  run_once: true

- name: Stat inventory directories for each candidate
  ansible.builtin.stat:
    path: "{{ item.path }}/{{ inventories_dir_name }}"
  register: _inv_dir_stats
  loop: "{{ root_candidates }}"
  loop_control:
    label: "{{ item.label }} -> inventories/"
  delegate_to: localhost
  run_once: true

- name: Scan markers in candidate inventories
  block:
  - name: Stat markers
    ansible.builtin.stat:
      path: "{{ item.0.path }}/{{ inventories_dir_name }}/{{ item.1 }}"
    register: _marker_stats
    loop: "{{ root_candidates | product(inventories_marker_candidates) | list }}"
    loop_control:
      label: "{{ item.0.label }} -> {{ item.1 }}"
    delegate_to: localhost
    run_once: true

  - name: Select project root by first marker match
    ansible.builtin.set_fact:
      project_root: "{{ (_marker_stats.results | selectattr('stat.exists') | list | map(attribute='item.0.path') | list | first) | default('') }}"
      detection_method: "{{ (_marker_stats.results | selectattr('stat.exists') | list | length) | ternary('inventories_marker', '') }}"
    delegate_to: localhost
    run_once: true
  delegate_to: localhost
  run_once: true
- name: Resolve project root by inventories directory or fallback
  when: (project_root | default('')) | length == 0
  block:
  - name: Pick first candidate with inventories dir; fallback to last candidate
    ansible.builtin.set_fact:
      project_root: >-
        {{
          (
            root_candidates
            | zip(_inv_dir_stats.results)
            | selectattr('1.stat.exists')
            | map('first')
            | map(attribute='path')
            | list
            | first
          )
          | default(root_candidates | map(attribute='path') | list | last)
        }}
      detection_method: >-
        {{
          (
            root_candidates
            | zip(_inv_dir_stats.results)
            | selectattr('1.stat.exists')
            | map('first')
            | map(attribute='label')
            | list
            | first
          )
          | default(root_candidates | map(attribute='label') | list | last)
        }}
    delegate_to: localhost
    run_once: true

- name: Set inventory base path
  ansible.builtin.set_fact:
    inventory_base_path: "{{ project_root }}/{{ inventories_dir_name }}"
  delegate_to: localhost
  run_once: true

- name: Ensure inventories directory exists
  ansible.builtin.file:
    path: "{{ inventory_base_path }}"
    state: directory
    mode: '0755'
  delegate_to: localhost
  run_once: true
- name: Compute environment data file path
  ansible.builtin.set_fact:
    env_data_file: "{{ inventory_base_path }}/{{ env }}/group_vars/all/{{ ip_data_filename }}"
  delegate_to: localhost
  run_once: true

- name: Check environment data file exists
  ansible.builtin.stat:
    path: "{{ env_data_file }}"
  register: env_data_stat
  delegate_to: localhost
  run_once: true

- name: Fail if environment data file is missing
  ansible.builtin.fail:
    msg: "Environment data file not found: {{ env_data_file }} (root: {{ project_root }}, detection: {{ detection_method }})"
  when: not env_data_stat.stat.exists
  delegate_to: localhost
  run_once: true

- name: Load environment data
  ansible.builtin.include_vars:
    file: "{{ env_data_file }}"
  delegate_to: localhost
  run_once: true

- name: Validate environments[env]
  ansible.builtin.fail:
    msg: "'environments.{{ env }}' missing in {{ env_data_file }}. Available: {{ environments.keys() | list if environments is defined else [] }}"
  when: environments is not defined or (env not in environments)
  delegate_to: localhost
  run_once: true

- name: Generate inventory files
  ansible.builtin.include_tasks: gen_inventories.yml

- name: Summary - Environment Guard Execution Complete
  ansible.builtin.debug:
    msg: |
      Environment Guard completed successfully.
      Environment: {{ env }}
      Project Root: {{ project_root }}
      Inventory Path: {{ inventory_base_path }}
      Detection Method: {{ detection_method | default('N/A') }}
